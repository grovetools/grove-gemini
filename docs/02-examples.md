# Examples

This document provides examples for using `grove-gemini` for API calls and development workflows.

## Example 1: Basic API Requests

This example shows how to use the `gemapi request` command for direct interaction with the Gemini API.

### Making a Simple Request

A prompt can be provided as an argument. The tool sends the request to the default model and prints the response to standard output.

```bash
gemapi request "What is the Go programming language?"
```

### Using Files for Prompts and Outputs

Files can be used for longer prompts or to save output.

1.  **Create a prompt file:**

    ```bash
    echo "Write a simple 'Hello, World!' program in Go." > prompt.md
    ```

2.  **Run the request:**
    This command uses the `-f` flag to read the prompt from `prompt.md`, specifies a model with `-m`, and saves the generated code to `main.go` using the `-o` flag.

    ```bash
    gemapi request -f prompt.md -o main.go -m gemini-1.5-flash-latest
    ```

3.  **Verify the output:**
    The `main.go` file will contain the Go code generated by the API.

    ```bash
    cat main.go
    ```
    ```go
    package main

    import "fmt"

    func main() {
        fmt.Println("Hello, World!")
    }
    ```

## Example 2: Requests with Codebase Context

When a `.grove/rules` file is present, `gemapi` reads it to determine which project files to include in the request. This provides the model with the contents of the matched files.

1.  **Set up the project:**
    Create a Go project with two files.

    `main.go`:
    ```go
    package main

    import "fmt"

    func main() {
        message := GetGreeting()
        fmt.Println(message)
    }
    ```

    `greeting.go`:
    ```go
    package main

    func GetGreeting() string {
        return "Hello from a separate file!"
    }
    ```

2.  **Define the context rules:**
    Create a `.grove/rules` file to specify which files to include.

    ```bash
    mkdir -p .grove
    echo "*.go" > .grove/rules
    ```

3.  **Make a context-aware request:**
    `gemapi` finds the `.grove/rules` file, gathers all `.go` files, and attaches them to the request.

    ```bash
    gemapi request "Based on the provided code, what will be printed when I run the program?"
    ```

    The model receives the content of both `main.go` and `greeting.go` and can determine the output.

    **Expected Output:**
    ```
    Based on the provided code, when you run the program, it will print:

    Hello from a separate file!
    ```

4.  **Regenerating Context:**
    If the `.grove/rules` file changes, the `--regenerate` flag can be used to force `gemapi` to regenerate the context files before making a request.

    ```bash
    gemapi request --regenerate "Summarize the project based on the new rules."
    ```

## Example 3: Caching and Observability (Experimental)

WARNING: EXPERIMENTAL

For requests involving large, unchanging sets of files, `gemapi` can use the Gemini Caching API to store the context. This is an opt-in, experimental feature.

1.  **Enable Caching:**
    Caching is enabled by adding the `@enable-cache` directive to a `.grove/rules` file. This instructs `gemapi` to treat files matched by the rules as "cold context" for caching.

    `.grove/rules`:
    ```
    @enable-cache
    *.go
    ```

2.  **Run the first request to create the cache:**
    The first request with a new context will create a cache on Google's servers, which may increase latency for that initial call. The `--yes` flag can be used to skip the confirmation prompt.

    ```bash
    gemapi request --yes "What is the purpose of the GetGreeting function?"
    ```

3.  **Run a second request to use the cache:**
    Subsequent requests will reuse the existing cache if it is still valid. The token usage summary will show a number of `Cold (Cached)` tokens.

    ```bash
    gemapi request "How is the greeting message generated?"
    ```

4.  **Observability Commands:**
    `gemapi` provides commands to inspect API usage.

    *   **Inspect Caches**: Launches a terminal interface for viewing cache records, their status, and usage statistics.

        ```bash
        gemapi cache tui
        ```

    *   **Query Local Logs**: The `query local` command reads logs stored on the local machine.

        ```bash
        gemapi query local --hours 1
        ```
        This command displays a table of requests made in the last hour.

    *   **Query Billing Data**: The `query billing` command can read cost data from a BigQuery billing export, which requires a one-time setup in a GCP account.

        ```bash
        gemapi query billing \
          --project-id your-gcp-project \
          --dataset-id your_billing_dataset \
          --table-id your_billing_table
        ```
